/**
 * Title:     An implementation of try...catch exception
 *            handling using continuations
 * Author:    Dominic Verity
 * Copyright: Macquarie University (C) 2007-2014
 *
 * A try..catch block is implemented using 2 continuations:
 *        The first marks the exit point for normal exits.
 *        The second marks the entry point to the exception handler code.
 *
 * We might picture this arrangement as:
 *
 *  --- normal exit cont    --- error handler cont
 *   |                       |
 *   |                       |                    code in the try block
 *   |                       |
 *   |                       |         at the end of the try block throw to normal
 *   |                       V         exit continuation to avoid exectuing the exception
 *   |                      ___        handler after successful execution of try code.
 *   |
 *   |
 *   |                                         code of corresponding
 *   |                                         exception handler.
 *   V
 *  ---
 *
 * The SECD machine provides a primitive, called 'raise', which allows us
 * to raise an exception. This can be brought into scope in user code using the 'primitives'
 * key word. The same mechanism also allows us to bring the names of the exception
 * values associated with the various machine exceptions into scope. Having done that we can
 * write code to catch and handle different kinds of machine error.
 *
 * The creation of user exception values is supported by the 'newException' primitive.
 * User exception values may be 'raise'd just like machine exception values. User exception
 * values contain a string describing that type of exception. Like other values, we may
 * compare exception values for (in)equality (using == and !=), print them to the terminal
 * using the 'write' primitive and convert them to string values using the 'toString' primitive.
 *
 * To make exception handling a little easier to implement, the ExceptionHandler.scala extension
 * to the basic SECD machine adds an extra 'handler' register which is used to hold a continuation
 * marking the point to jump to when an exception occurs. The value of this 'handler' register
 * is stored in continuations. So when we resume a continuation the 'handler' register is re-set
 * to contain the value it had when that continuation was captured. This enables us to easily implement
 * the correct semantics for nested try...catch blocks.
 *
 * On the other hand, the value of the 'handler' register is not stored in a closure when it is built.
 * That means that the exception handler in play when we execute a closure is the one that was in place
 * at the point when the closure was entered rather than the one from the point at which the closure was
 * created. In other words, we can think of the current exception handler as being stored in a dynamically
 * scoped, globally accessible 'handler' variable.
 *
 * There are a number of other places where such dynamically scoped variables are useful in implementing
 * control structures. So one might consider extending ISWIM and the SECD machine to allow us to declare
 * variables which are dynamically scoped in user code.... but we haven't done so yet!
 *
 * The code below implements try...catch as a function:
 *
 * tryCatch try catch - which takes parameters:
 *      a function try() representing the body of the try..catch
 *      a function catch(exn) representing the corresponding catch block,
 *                 this takes as its parameter the exception object given at
 *                 the point where the error we are handling was raised.
 *
 * The actual implementation of this function is remarkably simple.
 */

// Bring some useful primitives into scope
primitives write, newException, raise, setHandler, DivisionByZero, TypeError;

// Write a value followed by a newline
let writeln = fun(v) {
    write v;
    write "\n"
};

// The exception handler function itself
let tryCatch = fun(try) fun(catch) (
    callcc (fun(exitTry)
        let ex = callcc (fun(catchBlock) {
            setHandler catchBlock;
            throw try() to exitTry
        }) in (catch ex)
    )
);

// Now for some tests.
{
    // Simple test.
    writeln "Probably the simplest possible test of exception handling:";
    write "\n";

    let exn = newException "simplest possible test"
    in tryCatch (fun(a) {
        writeln "One";
        raise exn;
        writeln "Two"
    }) (fun(err) {
        writeln err
    });

    // Re-raising exceptions
    write "\n";
    writeln "A test that the re-raising of exceptions works properly:";
    write "\n";

    let exn = newException "re-raising exception"
    in tryCatch (fun(a) {
        writeln "Three";
        tryCatch (fun(a) {
            writeln "Four";
            raise exn;
            writeln "Five"
        }) (fun(err) {
            writeln "Inner Exception Handler.";
            writeln err;
            raise err
        });
        writeln "Six"
    }) (fun(err) {
        writeln "Outer Exception Handler.";
        writeln err
    });

    // Machine errors and exception handling
    write "\n";
    writeln "A test that we can catch machine errors and work out what they are:";
    write "\n";

    let errorHandler = fun(err)
        if (err == DivisionByZero)
            writeln "division by zero error caught."
        else if (err == TypeError)
            writeln "type error caught."
        else
            writeln "some other error caught."
    in {
        tryCatch(fun(a) {
            10 / 0
        }) errorHandler;

        tryCatch(fun(a) {
            0 + ()
        }) errorHandler;

        tryCatch(fun(a) {
           10 match { () -> "hello hello" }
        }) errorHandler
    };

    // Exceptions and recursion.
    write "\n";
    writeln "A test that exceptions work as expected when they are raised within a recursive function:";
    write "\n";

    let exn = newException "recursion exception"
    in letrec test = fun(n)
        if (20 <= n) raise exn
        else {
            writeln "before";
            writeln n;
            test (n + 1);
            writeln "after"
        }
        in tryCatch (fun(a) {
            test 0
        }) (fun(err) {
            writeln err
        });

    // Exceptions and lexical / dynamic scope
    write "\n";
    writeln "Test that the current exception handler is determined by the point from which a closure is called";
    writeln "not the place at which it was constructed:";
    write "\n";

    let exn = newException "check dynamic scoping of the exception handler"
    in  let f = tryCatch(fun(a) {
            fun(b)(raise exn)       // build a closure within a try...catch block and bind it to f
        }) (fun(err) {
            writeln "whoops - the current exception handler is lexically scoped..."
        })
        in tryCatch(fun(a) {
            f ()                    // call f to raise our exception.
        }) (fun(err) {
            writeln "phew - the exception handler is dynamically scoped after all :-)"
        })
}
